"use strict";
/**
 * Comparison Generator - NEW feature for run comparison
 * Compare current run vs baseline to show new failures, fixed tests, regressions, improvements
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComparison = generateComparison;
exports.generateComparisonScript = generateComparisonScript;
exports.buildComparison = buildComparison;
const utils_1 = require("../utils");
/**
 * Generate comparison view between current and baseline runs
 */
function generateComparison(comparison) {
    const { baselineRun, currentRun, changes } = comparison;
    // Calculate deltas
    const passRateDelta = currentRun.passRate - baselineRun.passRate;
    const durationDelta = currentRun.duration - baselineRun.duration;
    const durationPctChange = baselineRun.duration > 0
        ? ((durationDelta / baselineRun.duration) * 100).toFixed(1)
        : '0';
    return `
    <div class="comparison-section">
      <div class="comparison-header">
        <div class="comparison-title">ğŸ”„ Run Comparison</div>
        <div class="comparison-subtitle">
          Baseline: ${new Date(baselineRun.timestamp).toLocaleDateString()} vs Current
        </div>
      </div>

      <!-- Summary Cards -->
      <div class="comparison-summary">
        <div class="comparison-card">
          <div class="comparison-card-label">Pass Rate</div>
          <div class="comparison-card-value ${passRateDelta >= 0 ? 'positive' : 'negative'}">
            ${currentRun.passRate}%
            <span class="comparison-delta">
              ${passRateDelta >= 0 ? 'â†‘' : 'â†“'} ${Math.abs(passRateDelta).toFixed(1)}%
            </span>
          </div>
        </div>

        <div class="comparison-card">
          <div class="comparison-card-label">Duration</div>
          <div class="comparison-card-value ${durationDelta <= 0 ? 'positive' : 'negative'}">
            ${(0, utils_1.formatDuration)(currentRun.duration)}
            <span class="comparison-delta">
              ${durationDelta <= 0 ? 'â†“' : 'â†‘'} ${durationPctChange}%
            </span>
          </div>
        </div>

        <div class="comparison-card">
          <div class="comparison-card-label">Tests</div>
          <div class="comparison-card-value">
            ${currentRun.total}
            <span class="comparison-delta neutral">
              ${currentRun.total - baselineRun.total >= 0 ? '+' : ''}${currentRun.total - baselineRun.total}
            </span>
          </div>
        </div>

        <div class="comparison-card">
          <div class="comparison-card-label">Flaky</div>
          <div class="comparison-card-value ${currentRun.flaky - baselineRun.flaky <= 0 ? 'positive' : 'negative'}">
            ${currentRun.flaky}
            <span class="comparison-delta">
              ${currentRun.flaky - baselineRun.flaky >= 0 ? '+' : ''}${currentRun.flaky - baselineRun.flaky}
            </span>
          </div>
        </div>
      </div>

      <!-- Change Details -->
      <div class="comparison-details">
        ${generateComparisonSection('ğŸ†• New Failures', changes.newFailures, 'failure')}
        ${generateComparisonSection('âœ… Fixed Tests', changes.fixedTests, 'fixed')}
        ${generateComparisonSection('ğŸ¢ Performance Regressions', changes.regressions, 'regression')}
        ${generateComparisonSection('âš¡ Performance Improvements', changes.improvements, 'improvement')}
        ${generateComparisonSection('ğŸ“ New Tests', changes.newTests, 'new')}
      </div>
    </div>
  `;
}
/**
 * Generate a single comparison section
 */
function generateComparisonSection(title, tests, type) {
    if (tests.length === 0) {
        return '';
    }
    const sectionId = (0, utils_1.sanitizeId)(title);
    const colorClass = getColorClass(type);
    return `
    <div class="comparison-section-wrapper">
      <div class="comparison-section-header ${colorClass}" onclick="toggleComparisonSection('${sectionId}')">
        <span class="expand-icon">â–¼</span>
        <span class="comparison-section-title">${title}</span>
        <span class="comparison-section-count">${tests.length}</span>
      </div>
      <div id="section-${sectionId}" class="comparison-section-content">
        ${tests.map(test => generateComparisonItem(test, type)).join('')}
      </div>
    </div>
  `;
}
/**
 * Generate a single comparison item
 */
function generateComparisonItem(test, type) {
    const itemId = (0, utils_1.sanitizeId)(test.testId);
    let details = '';
    if (type === 'regression' || type === 'improvement') {
        const avgDuration = test.averageDuration || 0;
        const pctChange = avgDuration > 0
            ? (((test.duration - avgDuration) / avgDuration) * 100).toFixed(1)
            : '0';
        details = `
      <div class="comparison-item-details">
        <span class="comparison-item-duration">
          ${(0, utils_1.formatDuration)(avgDuration)} â†’ ${(0, utils_1.formatDuration)(test.duration)}
        </span>
        <span class="comparison-item-change ${type === 'regression' ? 'negative' : 'positive'}">
          ${type === 'regression' ? 'â†‘' : 'â†“'} ${Math.abs(parseFloat(pctChange))}%
        </span>
      </div>
    `;
    }
    if (type === 'failure' && test.error) {
        details = `
      <div class="comparison-item-error">
        ${(0, utils_1.escapeHtml)(test.error.substring(0, 150))}${test.error.length > 150 ? '...' : ''}
      </div>
    `;
    }
    return `
    <div class="comparison-item" id="comparison-${itemId}">
      <div class="comparison-item-header">
        <div class="comparison-item-status ${test.status}"></div>
        <div class="comparison-item-info">
          <div class="comparison-item-title">${(0, utils_1.escapeHtml)(test.title)}</div>
          <div class="comparison-item-file">${(0, utils_1.escapeHtml)(test.file)}</div>
        </div>
        <div class="comparison-item-duration-badge">${(0, utils_1.formatDuration)(test.duration)}</div>
      </div>
      ${details}
    </div>
  `;
}
/**
 * Get color class for section type
 */
function getColorClass(type) {
    switch (type) {
        case 'failure': return 'failure-section';
        case 'fixed': return 'fixed-section';
        case 'regression': return 'regression-section';
        case 'improvement': return 'improvement-section';
        case 'new': return 'new-section';
        default: return '';
    }
}
/**
 * Generate JavaScript for comparison functionality
 */
function generateComparisonScript() {
    return `
    function toggleComparisonSection(sectionId) {
      const section = document.getElementById('section-' + sectionId);
      const header = section.previousElementSibling;
      const icon = header.querySelector('.expand-icon');

      if (section.style.display === 'none') {
        section.style.display = 'block';
        icon.textContent = 'â–¼';
      } else {
        section.style.display = 'none';
        icon.textContent = 'â–¶';
      }
    }
  `;
}
/**
 * Generate comparison from test results and baseline
 * This is a helper function that would be used by the SmartReporter to build the comparison
 */
function buildComparison(currentTests, currentSummary, baselineSummary, baselineTests) {
    const changes = {
        newFailures: [],
        fixedTests: [],
        newTests: [],
        regressions: [],
        improvements: []
    };
    for (const test of currentTests) {
        const baselineTest = baselineTests.get(test.testId);
        if (!baselineTest) {
            // New test
            changes.newTests.push(test);
            continue;
        }
        // Check for new failures
        if (test.status === 'failed' && baselineTest.status === 'passed') {
            changes.newFailures.push(test);
        }
        // Check for fixed tests
        if (test.status === 'passed' && baselineTest.status === 'failed') {
            changes.fixedTests.push(test);
        }
        // Check for performance regressions/improvements
        if (test.status === 'passed' && baselineTest.status === 'passed') {
            const baselineDuration = baselineTest.duration;
            const currentDuration = test.duration;
            const pctChange = (currentDuration - baselineDuration) / baselineDuration;
            if (pctChange > 0.2) { // 20% slower
                changes.regressions.push({
                    ...test,
                    averageDuration: baselineDuration
                });
            }
            else if (pctChange < -0.2) { // 20% faster
                changes.improvements.push({
                    ...test,
                    averageDuration: baselineDuration
                });
            }
        }
    }
    return {
        baselineRun: baselineSummary,
        currentRun: currentSummary,
        changes
    };
}
