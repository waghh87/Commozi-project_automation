"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StabilityScorer = void 0;
/**
 * Calculates comprehensive stability scores for tests and test suites
 */
class StabilityScorer {
    constructor(stabilityThreshold = 70) {
        this.stabilityThreshold = stabilityThreshold;
    }
    /**
     * Calculate stability score for a single test
     */
    scoreTest(test) {
        // Calculate component scores
        const flakiness = this.calculateFlakinessScore(test);
        const performance = this.calculatePerformanceScore(test);
        const reliability = this.calculateReliabilityScore(test);
        // Overall score is weighted average
        const overall = Math.round(flakiness * 0.4 + // Flakiness is most important
            performance * 0.3 + // Performance is second
            reliability * 0.3 // Reliability is third
        );
        const grade = this.getGrade(overall);
        const needsAttention = overall < this.stabilityThreshold;
        test.stabilityScore = {
            overall,
            flakiness,
            performance,
            reliability,
            grade,
            needsAttention,
        };
    }
    /**
     * Calculate flakiness component (0-100, higher is better)
     */
    calculateFlakinessScore(test) {
        if (test.flakinessScore === undefined)
            return 100; // New test, assume stable
        // Convert flakiness score (0-1, higher is worse) to stability score (0-100, higher is better)
        return Math.round((1 - test.flakinessScore) * 100);
    }
    /**
     * Calculate performance component (0-100, higher is better)
     */
    calculatePerformanceScore(test) {
        const metrics = test.performanceMetrics;
        if (!metrics)
            return 100; // No history, assume good
        // If test improved, give bonus
        if (metrics.isImprovement)
            return 100;
        // If test is stable, give good score
        if (!metrics.isRegression)
            return 90;
        // Score based on severity of regression
        switch (metrics.severity) {
            case 'low': return 75;
            case 'medium': return 50;
            case 'high': return 25;
            default: return 100;
        }
    }
    /**
     * Calculate reliability component (0-100, higher is better)
     */
    calculateReliabilityScore(test) {
        const retry = test.retryInfo;
        // Passed without retries = excellent
        if (test.status === 'passed' && (!retry || retry.totalRetries === 0)) {
            return 100;
        }
        // Passed with retries = good but concerning
        if (test.status === 'passed' && retry && retry.totalRetries > 0) {
            return Math.max(50, 100 - (retry.totalRetries * 15));
        }
        // Failed = bad
        if (test.status === 'failed' || test.status === 'timedOut') {
            return retry ? Math.max(0, 40 - (retry.totalRetries * 10)) : 40;
        }
        // Skipped = neutral
        if (test.status === 'skipped') {
            return 75;
        }
        return 50;
    }
    /**
     * Convert numeric score to letter grade
     */
    getGrade(score) {
        if (score >= 90)
            return 'A';
        if (score >= 80)
            return 'B';
        if (score >= 70)
            return 'C';
        if (score >= 60)
            return 'D';
        return 'F';
    }
    /**
     * Calculate suite-wide statistics
     */
    calculateSuiteStats(results) {
        const total = results.length;
        const passed = results.filter(r => r.status === 'passed').length;
        const failed = results.filter(r => r.status === 'failed' || r.status === 'timedOut').length;
        const skipped = results.filter(r => r.status === 'skipped').length;
        const flaky = results.filter(r => r.flakinessScore && r.flakinessScore >= 0.3).length;
        const slow = results.filter(r => r.performanceTrend?.startsWith('↑')).length;
        const needsRetry = results.filter(r => r.retryInfo?.needsAttention).length;
        const passRate = (passed + failed) > 0
            ? Math.round((passed / (passed + failed)) * 100)
            : 0;
        // Calculate average stability from tests that have scores
        const testsWithScores = results.filter(r => r.stabilityScore);
        const averageStability = testsWithScores.length > 0
            ? Math.round(testsWithScores.reduce((sum, r) => sum + r.stabilityScore.overall, 0) /
                testsWithScores.length)
            : 0;
        return {
            total,
            passed,
            failed,
            skipped,
            flaky,
            slow,
            needsRetry,
            passRate,
            averageStability,
        };
    }
    /**
     * Get tests that need attention based on stability score
     */
    getProblematicTests(results) {
        return results.filter(r => r.stabilityScore?.needsAttention);
    }
    /**
     * Get stability summary string
     */
    getSummary(score) {
        return `Grade ${score.grade} (${score.overall}/100) - ${score.needsAttention ? '⚠️ Needs Attention' : '✅ Stable'}`;
    }
}
exports.StabilityScorer = StabilityScorer;
