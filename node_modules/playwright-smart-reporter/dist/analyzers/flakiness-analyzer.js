"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlakinessAnalyzer = void 0;
/**
 * Analyzes test flakiness based on historical pass/fail patterns
 */
class FlakinessAnalyzer {
    /**
     * Calculate flakiness score and indicator for a test
     * @param test - The test result to analyze
     * @param history - Historical test results for this test
     */
    analyze(test, history) {
        // For skipped tests, set a special indicator
        if (test.status === 'skipped') {
            test.flakinessIndicator = 'âšª Skipped';
            return;
        }
        if (history.length === 0) {
            test.flakinessIndicator = 'âšª New';
            return;
        }
        // Filter out skipped runs for flakiness calculation
        const relevantHistory = history.filter(e => !e.skipped);
        if (relevantHistory.length === 0) {
            // All history entries were skipped
            test.flakinessIndicator = 'âšª New';
            return;
        }
        const failures = relevantHistory.filter(e => !e.passed).length;
        const flakinessScore = failures / relevantHistory.length;
        test.flakinessScore = flakinessScore;
        test.flakinessIndicator = this.getFlakinessIndicator(flakinessScore);
    }
    /**
     * Get human-readable flakiness indicator
     */
    getFlakinessIndicator(score) {
        if (score < 0.1)
            return 'ðŸŸ¢ Stable';
        if (score < 0.3)
            return 'ðŸŸ¡ Unstable';
        return 'ðŸ”´ Flaky';
    }
    /**
     * Get flakiness status for filtering
     */
    getStatus(score) {
        if (score === undefined)
            return 'new';
        if (score < 0.1)
            return 'stable';
        if (score < 0.3)
            return 'unstable';
        return 'flaky';
    }
}
exports.FlakinessAnalyzer = FlakinessAnalyzer;
