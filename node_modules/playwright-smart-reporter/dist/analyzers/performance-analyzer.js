"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceAnalyzer = void 0;
/**
 * Analyzes test performance trends and regressions
 */
class PerformanceAnalyzer {
    constructor(performanceThreshold = 0.2) {
        this.performanceThreshold = performanceThreshold;
    }
    /**
     * Analyze performance trend for a test
     */
    analyze(test, history) {
        if (test.status === 'skipped') {
            test.performanceTrend = '→ Skipped';
            return;
        }
        if (history.length === 0) {
            test.performanceTrend = '→ Baseline';
            return;
        }
        // Filter out skipped runs for performance calculation
        const relevantHistory = history.filter(e => !e.skipped);
        if (relevantHistory.length === 0) {
            test.performanceTrend = '→ Baseline';
            return;
        }
        // Calculate average duration from history
        const avgDuration = relevantHistory.reduce((sum, e) => sum + e.duration, 0) / relevantHistory.length;
        test.averageDuration = avgDuration;
        // Calculate performance trend
        test.performanceTrend = this.getPerformanceTrend(test.duration, avgDuration);
        // Add detailed performance metrics
        test.performanceMetrics = this.calculateMetrics(test.duration, avgDuration);
    }
    /**
     * Get human-readable performance trend
     */
    getPerformanceTrend(current, average) {
        const diff = (current - average) / average;
        if (diff > this.performanceThreshold) {
            return `↑ ${Math.round(diff * 100)}% slower`;
        }
        if (diff < -this.performanceThreshold) {
            return `↓ ${Math.round(Math.abs(diff) * 100)}% faster`;
        }
        return '→ Stable';
    }
    /**
     * Calculate detailed performance metrics
     */
    calculateMetrics(current, average) {
        const percentChange = ((current - average) / average) * 100;
        const absoluteChange = current - average;
        const isRegression = percentChange > this.performanceThreshold * 100;
        const isImprovement = percentChange < -this.performanceThreshold * 100;
        // Determine severity based on magnitude of change
        let severity = 'low';
        const absPercentChange = Math.abs(percentChange);
        if (absPercentChange > 50) {
            severity = 'high';
        }
        else if (absPercentChange > 25) {
            severity = 'medium';
        }
        return {
            averageDuration: average,
            currentDuration: current,
            percentChange,
            absoluteChange,
            threshold: this.performanceThreshold,
            isRegression,
            isImprovement,
            severity,
        };
    }
    /**
     * Check if test is slow compared to history
     */
    isSlow(test) {
        return test.performanceTrend?.startsWith('↑') || false;
    }
    /**
     * Check if test improved performance
     */
    isFaster(test) {
        return test.performanceTrend?.startsWith('↓') || false;
    }
    /**
     * Get performance status for filtering
     */
    getStatus(trend) {
        if (!trend)
            return 'stable';
        if (trend.startsWith('↑'))
            return 'slow';
        if (trend.startsWith('↓'))
            return 'fast';
        return 'stable';
    }
    /**
     * Calculate smart thresholds based on test duration
     * Shorter tests should have tighter thresholds
     */
    calculateSmartThreshold(duration) {
        // For very fast tests (<100ms), use tighter threshold
        if (duration < 100)
            return 0.5; // 50% variance allowed
        // For fast tests (<1s), use moderate threshold
        if (duration < 1000)
            return 0.3; // 30% variance allowed
        // For normal tests (<10s), use default threshold
        if (duration < 10000)
            return this.performanceThreshold;
        // For slow tests (>10s), use looser threshold
        return 0.15; // 15% variance allowed
    }
}
exports.PerformanceAnalyzer = PerformanceAnalyzer;
