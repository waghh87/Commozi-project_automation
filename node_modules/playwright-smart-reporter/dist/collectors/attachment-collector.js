"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttachmentCollector = void 0;
const fs = __importStar(require("fs"));
/**
 * Collects and processes test attachments (screenshots, videos, traces)
 */
class AttachmentCollector {
    /**
     * Collect all attachments from a test result
     * @param result - Playwright TestResult
     * @returns Attachment data with base64 screenshots and file paths
     */
    collectAttachments(result) {
        const attachments = {
            screenshots: [],
            videos: [],
            traces: [],
        };
        // Collect screenshots
        const screenshots = result.attachments.filter(a => a.name === 'screenshot' && a.contentType.startsWith('image/'));
        for (const screenshot of screenshots) {
            if (screenshot.body) {
                const dataUri = `data:${screenshot.contentType};base64,${screenshot.body.toString('base64')}`;
                attachments.screenshots.push(dataUri);
            }
            else if (screenshot.path) {
                // Read file and convert to base64
                try {
                    const imgBuffer = fs.readFileSync(screenshot.path);
                    const dataUri = `data:${screenshot.contentType};base64,${imgBuffer.toString('base64')}`;
                    attachments.screenshots.push(dataUri);
                }
                catch (err) {
                    console.warn(`Failed to read screenshot: ${screenshot.path}`, err);
                }
            }
        }
        // Collect videos
        const videos = result.attachments.filter(a => a.name === 'video' && a.contentType.startsWith('video/'));
        for (const video of videos) {
            if (video.path) {
                attachments.videos.push(video.path);
            }
        }
        // Collect traces (NEW for PR #2)
        const traces = result.attachments.filter(a => a.name === 'trace' && a.path);
        for (const trace of traces) {
            if (trace.path) {
                attachments.traces.push(trace.path);
            }
        }
        return attachments;
    }
    /**
     * Get the first screenshot (for backwards compatibility)
     * @param attachments - Attachment data
     * @returns First screenshot data URI or undefined
     */
    getFirstScreenshot(attachments) {
        return attachments.screenshots[0];
    }
    /**
     * Get the first video path (for backwards compatibility)
     * @param attachments - Attachment data
     * @returns First video path or undefined
     */
    getFirstVideo(attachments) {
        return attachments.videos[0];
    }
    /**
     * Check if test has any attachments
     * @param attachments - Attachment data
     * @returns True if any attachments exist
     */
    hasAttachments(attachments) {
        return attachments.screenshots.length > 0 ||
            attachments.videos.length > 0 ||
            attachments.traces.length > 0;
    }
}
exports.AttachmentCollector = AttachmentCollector;
